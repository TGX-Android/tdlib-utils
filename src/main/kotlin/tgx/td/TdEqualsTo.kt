/*
 * This file is a part of tdlib-utils
 * Copyright Â© 2014 (tgx-android@pm.me)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:JvmName("Td")
@file:JvmMultifileClass

package tgx.td

import me.vkryl.annotation.Autogenerated
import org.drinkless.tdlib.TdApi.*
import kotlin.contracts.ExperimentalContracts

// Arrays

@Autogenerated
fun Array<Array<InlineKeyboardButton>>?.equalsTo(other: Array<Array<InlineKeyboardButton>>?): Boolean = 
  this.contentEqualsOrEmpty(other, Array<InlineKeyboardButton>::equalsTo)

@Autogenerated
fun Array<Array<KeyboardButton>>?.equalsTo(other: Array<Array<KeyboardButton>>?): Boolean = 
  this.contentEqualsOrEmpty(other, Array<KeyboardButton>::equalsTo)

@Autogenerated
fun Array<ClosedVectorPath>?.equalsTo(other: Array<ClosedVectorPath>?): Boolean = 
  this.contentEqualsOrEmpty(other, ClosedVectorPath::equalsTo)

@Autogenerated
fun Array<Document>?.equalsTo(other: Array<Document>?): Boolean = 
  this.contentEqualsOrEmpty(other, Document::equalsTo)

@Autogenerated
fun Array<InlineKeyboardButton>?.equalsTo(other: Array<InlineKeyboardButton>?): Boolean = 
  this.contentEqualsOrEmpty(other, InlineKeyboardButton::equalsTo)

@Autogenerated
fun Array<KeyboardButton>?.equalsTo(other: Array<KeyboardButton>?): Boolean = 
  this.contentEqualsOrEmpty(other, KeyboardButton::equalsTo)

@Autogenerated
fun Array<LinkPreviewAlbumMedia>?.equalsTo(other: Array<LinkPreviewAlbumMedia>?): Boolean = 
  this.contentEqualsOrEmpty(other, LinkPreviewAlbumMedia::equalsTo)

@Autogenerated
fun Array<Sticker>?.equalsTo(other: Array<Sticker>?): Boolean = 
  this.contentEqualsOrEmpty(other, Sticker::equalsTo)

@Autogenerated
fun Array<Thumbnail>?.equalsTo(other: Array<Thumbnail>?): Boolean = 
  this.contentEqualsOrEmpty(other, Thumbnail::equalsTo)

@Autogenerated
fun Array<VectorPathCommand>?.equalsTo(other: Array<VectorPathCommand>?): Boolean = 
  this.contentEqualsOrEmpty(other, VectorPathCommand::equalsTo)

// Contents

@Autogenerated
fun AccentColor?.equalsTo(other: AccentColor?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    AccentColor(
      this.id,
      this.builtInAccentColorId,
      this.lightThemeColors,
      this.darkThemeColors,
      this.minChannelChatBoostLevel
    )
  }
  this.id == b.id &&
  this.builtInAccentColorId == b.builtInAccentColorId &&
  this.minChannelChatBoostLevel == b.minChannelChatBoostLevel &&
  this.lightThemeColors.contentEqualsOrEmpty(b.lightThemeColors) &&
  this.darkThemeColors.contentEqualsOrEmpty(b.darkThemeColors)
}

@Autogenerated
fun AnimatedChatPhoto?.equalsTo(other: AnimatedChatPhoto?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    AnimatedChatPhoto(
      this.length,
      this.file,
      this.mainFrameTimestamp
    )
  }
  this.length == b.length &&
  this.mainFrameTimestamp == b.mainFrameTimestamp &&
  this.file.equalsTo(b.file)
}

@Autogenerated
fun Animation?.equalsTo(other: Animation?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    Animation(
      this.duration,
      this.width,
      this.height,
      this.fileName,
      this.mimeType,
      this.hasStickers,
      this.minithumbnail,
      this.thumbnail,
      this.animation
    )
  }
  this.duration == b.duration &&
  this.width == b.width &&
  this.height == b.height &&
  this.hasStickers == b.hasStickers &&
  this.fileName.equalsOrEmpty(b.fileName) &&
  this.mimeType.equalsOrEmpty(b.mimeType) &&
  this.minithumbnail.equalsTo(b.minithumbnail) &&
  this.thumbnail.equalsTo(b.thumbnail) &&
  this.animation.equalsTo(b.animation)
}

@Autogenerated
fun Audio?.equalsTo(other: Audio?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    Audio(
      this.duration,
      this.title,
      this.performer,
      this.fileName,
      this.mimeType,
      this.albumCoverMinithumbnail,
      this.albumCoverThumbnail,
      this.externalAlbumCovers,
      this.audio
    )
  }
  this.duration == b.duration &&
  this.title.equalsOrEmpty(b.title) &&
  this.performer.equalsOrEmpty(b.performer) &&
  this.fileName.equalsOrEmpty(b.fileName) &&
  this.mimeType.equalsOrEmpty(b.mimeType) &&
  this.albumCoverMinithumbnail.equalsTo(b.albumCoverMinithumbnail) &&
  this.albumCoverThumbnail.equalsTo(b.albumCoverThumbnail) &&
  this.externalAlbumCovers.equalsTo(b.externalAlbumCovers) &&
  this.audio.equalsTo(b.audio)
}

@Autogenerated
fun Background?.equalsTo(other: Background?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    Background(
      this.id,
      this.isDefault,
      this.isDark,
      this.name,
      this.document,
      this.type
    )
  }
  this.id == b.id &&
  this.isDefault == b.isDefault &&
  this.isDark == b.isDark &&
  this.name.equalsOrEmpty(b.name) &&
  this.document.equalsTo(b.document) &&
  this.type.equalsTo(b.type)
}

@Autogenerated
fun ChatAdministratorRights?.equalsTo(other: ChatAdministratorRights?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    ChatAdministratorRights(
      this.canManageChat,
      this.canChangeInfo,
      this.canPostMessages,
      this.canEditMessages,
      this.canDeleteMessages,
      this.canInviteUsers,
      this.canRestrictMembers,
      this.canPinMessages,
      this.canManageTopics,
      this.canPromoteMembers,
      this.canManageVideoChats,
      this.canPostStories,
      this.canEditStories,
      this.canDeleteStories,
      this.isAnonymous
    )
  }
  this.canManageChat == b.canManageChat &&
  this.canChangeInfo == b.canChangeInfo &&
  this.canPostMessages == b.canPostMessages &&
  this.canEditMessages == b.canEditMessages &&
  this.canDeleteMessages == b.canDeleteMessages &&
  this.canInviteUsers == b.canInviteUsers &&
  this.canRestrictMembers == b.canRestrictMembers &&
  this.canPinMessages == b.canPinMessages &&
  this.canManageTopics == b.canManageTopics &&
  this.canPromoteMembers == b.canPromoteMembers &&
  this.canManageVideoChats == b.canManageVideoChats &&
  this.canPostStories == b.canPostStories &&
  this.canEditStories == b.canEditStories &&
  this.canDeleteStories == b.canDeleteStories &&
  this.isAnonymous == b.isAnonymous
}

@Autogenerated
fun ChatFolderIcon?.equalsTo(other: ChatFolderIcon?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    ChatFolderIcon(
      this.name
    )
  }
  this.name.equalsOrEmpty(b.name)
}

@OptIn(ExperimentalContracts::class)
@Autogenerated
fun ChatFolderName?.equalsTo(other: ChatFolderName?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    ChatFolderName(
      this.text,
      this.animateCustomEmoji
    )
  }
  this.animateCustomEmoji == b.animateCustomEmoji &&
  this.text.equalsTo(b.text)
}

@Autogenerated
fun ChatPermissions?.equalsTo(other: ChatPermissions?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    ChatPermissions(
      this.canSendBasicMessages,
      this.canSendAudios,
      this.canSendDocuments,
      this.canSendPhotos,
      this.canSendVideos,
      this.canSendVideoNotes,
      this.canSendVoiceNotes,
      this.canSendPolls,
      this.canSendOtherMessages,
      this.canAddLinkPreviews,
      this.canChangeInfo,
      this.canInviteUsers,
      this.canPinMessages,
      this.canCreateTopics
    )
  }
  this.canSendBasicMessages == b.canSendBasicMessages &&
  this.canSendAudios == b.canSendAudios &&
  this.canSendDocuments == b.canSendDocuments &&
  this.canSendPhotos == b.canSendPhotos &&
  this.canSendVideos == b.canSendVideos &&
  this.canSendVideoNotes == b.canSendVideoNotes &&
  this.canSendVoiceNotes == b.canSendVoiceNotes &&
  this.canSendPolls == b.canSendPolls &&
  this.canSendOtherMessages == b.canSendOtherMessages &&
  this.canAddLinkPreviews == b.canAddLinkPreviews &&
  this.canChangeInfo == b.canChangeInfo &&
  this.canInviteUsers == b.canInviteUsers &&
  this.canPinMessages == b.canPinMessages &&
  this.canCreateTopics == b.canCreateTopics
}

@Autogenerated
fun ChatPhoto?.equalsTo(other: ChatPhoto?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    ChatPhoto(
      this.id,
      this.addedDate,
      this.minithumbnail,
      this.sizes,
      this.animation,
      this.smallAnimation,
      this.sticker
    )
  }
  this.id == b.id &&
  this.addedDate == b.addedDate &&
  this.minithumbnail.equalsTo(b.minithumbnail) &&
  this.sizes.equalsTo(b.sizes) &&
  this.animation.equalsTo(b.animation) &&
  this.smallAnimation.equalsTo(b.smallAnimation) &&
  this.sticker.equalsTo(b.sticker)
}

@Autogenerated
fun ChatPhotoSticker?.equalsTo(other: ChatPhotoSticker?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    ChatPhotoSticker(
      this.type,
      this.backgroundFill
    )
  }
  this.type.equalsTo(b.type) &&
  this.backgroundFill.equalsTo(b.backgroundFill)
}

@Autogenerated
fun ClosedVectorPath?.equalsTo(other: ClosedVectorPath?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    ClosedVectorPath(
      this.commands
    )
  }
  this.commands.equalsTo(b.commands)
}

@Autogenerated
fun Document?.equalsTo(other: Document?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    Document(
      this.fileName,
      this.mimeType,
      this.minithumbnail,
      this.thumbnail,
      this.document
    )
  }
  this.fileName.equalsOrEmpty(b.fileName) &&
  this.mimeType.equalsOrEmpty(b.mimeType) &&
  this.minithumbnail.equalsTo(b.minithumbnail) &&
  this.thumbnail.equalsTo(b.thumbnail) &&
  this.document.equalsTo(b.document)
}

@Autogenerated
fun Error?.equalsTo(other: Error?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    Error(
      this.code,
      this.message
    )
  }
  this.code == b.code &&
  this.message.equalsOrEmpty(b.message)
}

@Autogenerated
fun InlineKeyboardButton?.equalsTo(other: InlineKeyboardButton?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    InlineKeyboardButton(
      this.text,
      this.type
    )
  }
  this.text.equalsOrEmpty(b.text) &&
  this.type.equalsTo(b.type)
}

@Autogenerated
fun KeyboardButton?.equalsTo(other: KeyboardButton?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    KeyboardButton(
      this.text,
      this.type
    )
  }
  this.text.equalsOrEmpty(b.text) &&
  this.type.equalsTo(b.type)
}

@Autogenerated
fun LocalFile?.equalsTo(other: LocalFile?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    LocalFile(
      this.path,
      this.canBeDownloaded,
      this.canBeDeleted,
      this.isDownloadingActive,
      this.isDownloadingCompleted,
      this.downloadOffset,
      this.downloadedPrefixSize,
      this.downloadedSize
    )
  }
  this.canBeDownloaded == b.canBeDownloaded &&
  this.canBeDeleted == b.canBeDeleted &&
  this.isDownloadingActive == b.isDownloadingActive &&
  this.isDownloadingCompleted == b.isDownloadingCompleted &&
  this.downloadOffset == b.downloadOffset &&
  this.downloadedPrefixSize == b.downloadedPrefixSize &&
  this.downloadedSize == b.downloadedSize &&
  this.path.equalsOrEmpty(b.path)
}

@Autogenerated
fun MaskPosition?.equalsTo(other: MaskPosition?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    MaskPosition(
      this.point,
      this.xShift,
      this.yShift,
      this.scale
    )
  }
  this.xShift == b.xShift &&
  this.yShift == b.yShift &&
  this.scale == b.scale &&
  this.point.equalsTo(b.point)
}

@Autogenerated
fun Photo?.equalsTo(other: Photo?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    Photo(
      this.hasStickers,
      this.minithumbnail,
      this.sizes
    )
  }
  this.hasStickers == b.hasStickers &&
  this.minithumbnail.equalsTo(b.minithumbnail) &&
  this.sizes.equalsTo(b.sizes)
}

@Autogenerated
fun PhotoSize?.equalsTo(other: PhotoSize?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    PhotoSize(
      this.type,
      this.photo,
      this.width,
      this.height,
      this.progressiveSizes
    )
  }
  this.width == b.width &&
  this.height == b.height &&
  this.type.equalsOrEmpty(b.type) &&
  this.photo.equalsTo(b.photo) &&
  this.progressiveSizes.contentEqualsOrEmpty(b.progressiveSizes)
}

@Autogenerated
fun Point?.equalsTo(other: Point?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    Point(
      this.x,
      this.y
    )
  }
  this.x == b.x &&
  this.y == b.y
}

@Autogenerated
fun ProfileAccentColor?.equalsTo(other: ProfileAccentColor?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    ProfileAccentColor(
      this.id,
      this.lightThemeColors,
      this.darkThemeColors,
      this.minSupergroupChatBoostLevel,
      this.minChannelChatBoostLevel
    )
  }
  this.id == b.id &&
  this.minSupergroupChatBoostLevel == b.minSupergroupChatBoostLevel &&
  this.minChannelChatBoostLevel == b.minChannelChatBoostLevel &&
  this.lightThemeColors.equalsTo(b.lightThemeColors) &&
  this.darkThemeColors.equalsTo(b.darkThemeColors)
}

@Autogenerated
fun ProfileAccentColors?.equalsTo(other: ProfileAccentColors?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    ProfileAccentColors(
      this.paletteColors,
      this.backgroundColors,
      this.storyColors
    )
  }
  this.paletteColors.contentEqualsOrEmpty(b.paletteColors) &&
  this.backgroundColors.contentEqualsOrEmpty(b.backgroundColors) &&
  this.storyColors.contentEqualsOrEmpty(b.storyColors)
}

@Autogenerated
fun RemoteFile?.equalsTo(other: RemoteFile?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    RemoteFile(
      this.id,
      this.uniqueId,
      this.isUploadingActive,
      this.isUploadingCompleted,
      this.uploadedSize
    )
  }
  this.isUploadingActive == b.isUploadingActive &&
  this.isUploadingCompleted == b.isUploadingCompleted &&
  this.uploadedSize == b.uploadedSize &&
  this.id.equalsOrEmpty(b.id) &&
  this.uniqueId.equalsOrEmpty(b.uniqueId)
}

@Autogenerated
fun Sticker?.equalsTo(other: Sticker?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    Sticker(
      this.id,
      this.setId,
      this.width,
      this.height,
      this.emoji,
      this.format,
      this.fullType,
      this.thumbnail,
      this.sticker
    )
  }
  this.id == b.id &&
  this.setId == b.setId &&
  this.width == b.width &&
  this.height == b.height &&
  this.emoji.equalsOrEmpty(b.emoji) &&
  this.format.equalsTo(b.format) &&
  this.fullType.equalsTo(b.fullType) &&
  this.thumbnail.equalsTo(b.thumbnail) &&
  this.sticker.equalsTo(b.sticker)
}

@Autogenerated
fun TargetChatTypes?.equalsTo(other: TargetChatTypes?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    TargetChatTypes(
      this.allowUserChats,
      this.allowBotChats,
      this.allowGroupChats,
      this.allowChannelChats
    )
  }
  this.allowUserChats == b.allowUserChats &&
  this.allowBotChats == b.allowBotChats &&
  this.allowGroupChats == b.allowGroupChats &&
  this.allowChannelChats == b.allowChannelChats
}

@Autogenerated
fun TextEntity?.equalsTo(other: TextEntity?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    TextEntity(
      this.offset,
      this.length,
      this.type
    )
  }
  this.offset == b.offset &&
  this.length == b.length &&
  this.type.equalsTo(b.type)
}

@OptIn(ExperimentalContracts::class)
@Autogenerated
fun TextQuote?.equalsTo(other: TextQuote?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    TextQuote(
      this.text,
      this.position,
      this.isManual
    )
  }
  this.position == b.position &&
  this.isManual == b.isManual &&
  this.text.equalsTo(b.text)
}

@Autogenerated
fun ThemeSettings?.equalsTo(other: ThemeSettings?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    ThemeSettings(
      this.accentColor,
      this.background,
      this.outgoingMessageFill,
      this.animateOutgoingMessageFill,
      this.outgoingMessageAccentColor
    )
  }
  this.accentColor == b.accentColor &&
  this.animateOutgoingMessageFill == b.animateOutgoingMessageFill &&
  this.outgoingMessageAccentColor == b.outgoingMessageAccentColor &&
  this.background.equalsTo(b.background) &&
  this.outgoingMessageFill.equalsTo(b.outgoingMessageFill)
}

@Autogenerated
fun Thumbnail?.equalsTo(other: Thumbnail?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    Thumbnail(
      this.format,
      this.width,
      this.height,
      this.file
    )
  }
  this.width == b.width &&
  this.height == b.height &&
  this.format.equalsTo(b.format) &&
  this.file.equalsTo(b.file)
}

@OptIn(ExperimentalContracts::class)
@Autogenerated
fun UpgradedGift?.equalsTo(other: UpgradedGift?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    UpgradedGift(
      this.id,
      this.title,
      this.name,
      this.number,
      this.totalUpgradedCount,
      this.maxUpgradedCount,
      this.ownerId,
      this.ownerAddress,
      this.ownerName,
      this.giftAddress,
      this.model,
      this.symbol,
      this.backdrop,
      this.originalDetails
    )
  }
  this.id == b.id &&
  this.number == b.number &&
  this.totalUpgradedCount == b.totalUpgradedCount &&
  this.maxUpgradedCount == b.maxUpgradedCount &&
  this.title.equalsOrEmpty(b.title) &&
  this.name.equalsOrEmpty(b.name) &&
  this.ownerId.equalsTo(b.ownerId) &&
  this.ownerAddress.equalsOrEmpty(b.ownerAddress) &&
  this.ownerName.equalsOrEmpty(b.ownerName) &&
  this.giftAddress.equalsOrEmpty(b.giftAddress) &&
  this.model.equalsTo(b.model) &&
  this.symbol.equalsTo(b.symbol) &&
  this.backdrop.equalsTo(b.backdrop) &&
  this.originalDetails.equalsTo(b.originalDetails)
}

@Autogenerated
fun UpgradedGiftBackdrop?.equalsTo(other: UpgradedGiftBackdrop?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    UpgradedGiftBackdrop(
      this.name,
      this.colors,
      this.rarityPerMille
    )
  }
  this.rarityPerMille == b.rarityPerMille &&
  this.name.equalsOrEmpty(b.name) &&
  this.colors.equalsTo(b.colors)
}

@Autogenerated
fun UpgradedGiftBackdropColors?.equalsTo(other: UpgradedGiftBackdropColors?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    UpgradedGiftBackdropColors(
      this.centerColor,
      this.edgeColor,
      this.symbolColor,
      this.textColor
    )
  }
  this.centerColor == b.centerColor &&
  this.edgeColor == b.edgeColor &&
  this.symbolColor == b.symbolColor &&
  this.textColor == b.textColor
}

@Autogenerated
fun UpgradedGiftModel?.equalsTo(other: UpgradedGiftModel?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    UpgradedGiftModel(
      this.name,
      this.sticker,
      this.rarityPerMille
    )
  }
  this.rarityPerMille == b.rarityPerMille &&
  this.name.equalsOrEmpty(b.name) &&
  this.sticker.equalsTo(b.sticker)
}

@OptIn(ExperimentalContracts::class)
@Autogenerated
fun UpgradedGiftOriginalDetails?.equalsTo(other: UpgradedGiftOriginalDetails?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    UpgradedGiftOriginalDetails(
      this.senderId,
      this.receiverId,
      this.text,
      this.date
    )
  }
  this.date == b.date &&
  this.senderId.equalsTo(b.senderId) &&
  this.receiverId.equalsTo(b.receiverId) &&
  this.text.equalsTo(b.text)
}

@Autogenerated
fun UpgradedGiftSymbol?.equalsTo(other: UpgradedGiftSymbol?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    UpgradedGiftSymbol(
      this.name,
      this.sticker,
      this.rarityPerMille
    )
  }
  this.rarityPerMille == b.rarityPerMille &&
  this.name.equalsOrEmpty(b.name) &&
  this.sticker.equalsTo(b.sticker)
}

@Autogenerated
fun Usernames?.equalsTo(other: Usernames?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    Usernames(
      this.activeUsernames,
      this.disabledUsernames,
      this.editableUsername
    )
  }
  this.editableUsername.equalsOrEmpty(b.editableUsername) &&
  this.activeUsernames.contentEqualsOrEmpty(b.activeUsernames) &&
  this.disabledUsernames.contentEqualsOrEmpty(b.disabledUsernames)
}

@Autogenerated
fun Video?.equalsTo(other: Video?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    Video(
      this.duration,
      this.width,
      this.height,
      this.fileName,
      this.mimeType,
      this.hasStickers,
      this.supportsStreaming,
      this.minithumbnail,
      this.thumbnail,
      this.video
    )
  }
  this.duration == b.duration &&
  this.width == b.width &&
  this.height == b.height &&
  this.hasStickers == b.hasStickers &&
  this.supportsStreaming == b.supportsStreaming &&
  this.fileName.equalsOrEmpty(b.fileName) &&
  this.mimeType.equalsOrEmpty(b.mimeType) &&
  this.minithumbnail.equalsTo(b.minithumbnail) &&
  this.thumbnail.equalsTo(b.thumbnail) &&
  this.video.equalsTo(b.video)
}

@Autogenerated
fun VideoNote?.equalsTo(other: VideoNote?): Boolean = this.safeEqualsTo(other) { b ->
  if (COMPILE_CHECK) {
    VideoNote(
      this.duration,
      this.waveform,
      this.length,
      this.minithumbnail,
      this.thumbnail,
      this.speechRecognitionResult,
      this.video
    )
  }
  this.duration == b.duration &&
  this.length == b.length &&
  this.minithumbnail.equalsTo(b.minithumbnail) &&
  this.thumbnail.equalsTo(b.thumbnail) &&
  this.speechRecognitionResult.equalsTo(b.speechRecognitionResult) &&
  this.video.equalsTo(b.video) &&
  this.waveform.contentEqualsOrEmpty(b.waveform)
}

@Autogenerated
fun BackgroundFill?.equalsTo(other: BackgroundFill?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    BackgroundFillFreeformGradient.CONSTRUCTOR -> {
      require(this is BackgroundFillFreeformGradient && b is BackgroundFillFreeformGradient)
      if (COMPILE_CHECK) {
        BackgroundFillFreeformGradient(
          this.colors
        )
      }
      this.colors.contentEqualsOrEmpty(b.colors)
    }
    BackgroundFillGradient.CONSTRUCTOR -> {
      require(this is BackgroundFillGradient && b is BackgroundFillGradient)
      if (COMPILE_CHECK) {
        BackgroundFillGradient(
          this.topColor,
          this.bottomColor,
          this.rotationAngle
        )
      }
      this.topColor == b.topColor &&
      this.bottomColor == b.bottomColor &&
      this.rotationAngle == b.rotationAngle
    }
    BackgroundFillSolid.CONSTRUCTOR -> {
      require(this is BackgroundFillSolid && b is BackgroundFillSolid)
      if (COMPILE_CHECK) {
        BackgroundFillSolid(
          this.color
        )
      }
      this.color == b.color
    }
    else -> {
      assertBackgroundFill_6086fe10()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun CanSendMessageToUserResult?.equalsTo(other: CanSendMessageToUserResult?): Boolean = this.safeEqualsTo(other) { _ ->
  when (this.constructor) {
    CanSendMessageToUserResultOk.CONSTRUCTOR,
    CanSendMessageToUserResultUserIsDeleted.CONSTRUCTOR,
    CanSendMessageToUserResultUserRestrictsNewChats.CONSTRUCTOR ->
      true // nothing to compare
    else -> {
      assertCanSendMessageToUserResult_3ce8a048()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun ChatAction?.equalsTo(other: ChatAction?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    ChatActionCancel.CONSTRUCTOR,
    ChatActionChoosingContact.CONSTRUCTOR,
    ChatActionChoosingLocation.CONSTRUCTOR,
    ChatActionChoosingSticker.CONSTRUCTOR,
    ChatActionRecordingVideo.CONSTRUCTOR,
    ChatActionRecordingVideoNote.CONSTRUCTOR,
    ChatActionRecordingVoiceNote.CONSTRUCTOR,
    ChatActionStartPlayingGame.CONSTRUCTOR,
    ChatActionTyping.CONSTRUCTOR ->
      true // nothing to compare
    ChatActionUploadingDocument.CONSTRUCTOR -> {
      require(this is ChatActionUploadingDocument && b is ChatActionUploadingDocument)
      if (COMPILE_CHECK) {
        ChatActionUploadingDocument(
          this.progress
        )
      }
      this.progress == b.progress
    }
    ChatActionUploadingPhoto.CONSTRUCTOR -> {
      require(this is ChatActionUploadingPhoto && b is ChatActionUploadingPhoto)
      if (COMPILE_CHECK) {
        ChatActionUploadingPhoto(
          this.progress
        )
      }
      this.progress == b.progress
    }
    ChatActionUploadingVideo.CONSTRUCTOR -> {
      require(this is ChatActionUploadingVideo && b is ChatActionUploadingVideo)
      if (COMPILE_CHECK) {
        ChatActionUploadingVideo(
          this.progress
        )
      }
      this.progress == b.progress
    }
    ChatActionUploadingVideoNote.CONSTRUCTOR -> {
      require(this is ChatActionUploadingVideoNote && b is ChatActionUploadingVideoNote)
      if (COMPILE_CHECK) {
        ChatActionUploadingVideoNote(
          this.progress
        )
      }
      this.progress == b.progress
    }
    ChatActionUploadingVoiceNote.CONSTRUCTOR -> {
      require(this is ChatActionUploadingVoiceNote && b is ChatActionUploadingVoiceNote)
      if (COMPILE_CHECK) {
        ChatActionUploadingVoiceNote(
          this.progress
        )
      }
      this.progress == b.progress
    }
    ChatActionWatchingAnimations.CONSTRUCTOR -> {
      require(this is ChatActionWatchingAnimations && b is ChatActionWatchingAnimations)
      if (COMPILE_CHECK) {
        ChatActionWatchingAnimations(
          this.emoji
        )
      }
      this.emoji.equalsOrEmpty(b.emoji)
    }
    else -> {
      assertChatAction_e6a90de7()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun ChatActionBar?.equalsTo(other: ChatActionBar?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    ChatActionBarAddContact.CONSTRUCTOR,
    ChatActionBarInviteMembers.CONSTRUCTOR,
    ChatActionBarSharePhoneNumber.CONSTRUCTOR ->
      true // nothing to compare
    ChatActionBarJoinRequest.CONSTRUCTOR -> {
      require(this is ChatActionBarJoinRequest && b is ChatActionBarJoinRequest)
      if (COMPILE_CHECK) {
        ChatActionBarJoinRequest(
          this.title,
          this.isChannel,
          this.requestDate
        )
      }
      this.isChannel == b.isChannel &&
      this.requestDate == b.requestDate &&
      this.title.equalsOrEmpty(b.title)
    }
    ChatActionBarReportAddBlock.CONSTRUCTOR -> {
      require(this is ChatActionBarReportAddBlock && b is ChatActionBarReportAddBlock)
      if (COMPILE_CHECK) {
        ChatActionBarReportAddBlock(
          this.canUnarchive
        )
      }
      this.canUnarchive == b.canUnarchive
    }
    ChatActionBarReportSpam.CONSTRUCTOR -> {
      require(this is ChatActionBarReportSpam && b is ChatActionBarReportSpam)
      if (COMPILE_CHECK) {
        ChatActionBarReportSpam(
          this.canUnarchive
        )
      }
      this.canUnarchive == b.canUnarchive
    }
    else -> {
      assertChatActionBar_eedc82ed()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun ChatList?.equalsTo(other: ChatList?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    ChatListArchive.CONSTRUCTOR,
    ChatListMain.CONSTRUCTOR ->
      true // nothing to compare
    ChatListFolder.CONSTRUCTOR -> {
      require(this is ChatListFolder && b is ChatListFolder)
      if (COMPILE_CHECK) {
        ChatListFolder(
          this.chatFolderId
        )
      }
      this.chatFolderId == b.chatFolderId
    }
    else -> {
      assertChatList_db6c93ab()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun ChatMemberStatus?.equalsTo(other: ChatMemberStatus?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    ChatMemberStatusLeft.CONSTRUCTOR ->
      true // nothing to compare
    ChatMemberStatusAdministrator.CONSTRUCTOR -> {
      require(this is ChatMemberStatusAdministrator && b is ChatMemberStatusAdministrator)
      if (COMPILE_CHECK) {
        ChatMemberStatusAdministrator(
          this.customTitle,
          this.canBeEdited,
          this.rights
        )
      }
      this.customTitle.equalsOrEmpty(b.customTitle) &&
      this.rights.equalsTo(b.rights)
      // ignored: this.canBeEdited == b.canBeEdited
    }
    ChatMemberStatusBanned.CONSTRUCTOR -> {
      require(this is ChatMemberStatusBanned && b is ChatMemberStatusBanned)
      if (COMPILE_CHECK) {
        ChatMemberStatusBanned(
          this.bannedUntilDate
        )
      }
      this.bannedUntilDate == b.bannedUntilDate
    }
    ChatMemberStatusCreator.CONSTRUCTOR -> {
      require(this is ChatMemberStatusCreator && b is ChatMemberStatusCreator)
      if (COMPILE_CHECK) {
        ChatMemberStatusCreator(
          this.customTitle,
          this.isAnonymous,
          this.isMember
        )
      }
      this.isAnonymous == b.isAnonymous &&
      this.isMember == b.isMember &&
      this.customTitle.equalsOrEmpty(b.customTitle)
    }
    ChatMemberStatusMember.CONSTRUCTOR -> {
      require(this is ChatMemberStatusMember && b is ChatMemberStatusMember)
      if (COMPILE_CHECK) {
        ChatMemberStatusMember(
          this.memberUntilDate
        )
      }
      // ignored: this.memberUntilDate == b.memberUntilDate
      true // nothing to compare
    }
    ChatMemberStatusRestricted.CONSTRUCTOR -> {
      require(this is ChatMemberStatusRestricted && b is ChatMemberStatusRestricted)
      if (COMPILE_CHECK) {
        ChatMemberStatusRestricted(
          this.isMember,
          this.restrictedUntilDate,
          this.permissions
        )
      }
      this.isMember == b.isMember &&
      this.restrictedUntilDate == b.restrictedUntilDate &&
      this.permissions.equalsTo(b.permissions)
    }
    else -> {
      assertChatMemberStatus_33fc5755()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun ChatPhotoStickerType?.equalsTo(other: ChatPhotoStickerType?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    ChatPhotoStickerTypeCustomEmoji.CONSTRUCTOR -> {
      require(this is ChatPhotoStickerTypeCustomEmoji && b is ChatPhotoStickerTypeCustomEmoji)
      if (COMPILE_CHECK) {
        ChatPhotoStickerTypeCustomEmoji(
          this.customEmojiId
        )
      }
      this.customEmojiId == b.customEmojiId
    }
    ChatPhotoStickerTypeRegularOrMask.CONSTRUCTOR -> {
      require(this is ChatPhotoStickerTypeRegularOrMask && b is ChatPhotoStickerTypeRegularOrMask)
      if (COMPILE_CHECK) {
        ChatPhotoStickerTypeRegularOrMask(
          this.stickerSetId,
          this.stickerId
        )
      }
      this.stickerSetId == b.stickerSetId &&
      this.stickerId == b.stickerId
    }
    else -> {
      assertChatPhotoStickerType_b827816a()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun ChatSource?.equalsTo(other: ChatSource?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    ChatSourceMtprotoProxy.CONSTRUCTOR ->
      true // nothing to compare
    ChatSourcePublicServiceAnnouncement.CONSTRUCTOR -> {
      require(this is ChatSourcePublicServiceAnnouncement && b is ChatSourcePublicServiceAnnouncement)
      if (COMPILE_CHECK) {
        ChatSourcePublicServiceAnnouncement(
          this.type,
          this.text
        )
      }
      this.type.equalsOrEmpty(b.type) &&
      this.text.equalsOrEmpty(b.text)
    }
    else -> {
      assertChatSource_12b21238()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun DeviceToken?.equalsTo(other: DeviceToken?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    DeviceTokenApplePush.CONSTRUCTOR -> {
      require(this is DeviceTokenApplePush && b is DeviceTokenApplePush)
      if (COMPILE_CHECK) {
        DeviceTokenApplePush(
          this.deviceToken,
          this.isAppSandbox
        )
      }
      this.isAppSandbox == b.isAppSandbox &&
      this.deviceToken.equalsOrEmpty(b.deviceToken)
    }
    DeviceTokenApplePushVoIP.CONSTRUCTOR -> {
      require(this is DeviceTokenApplePushVoIP && b is DeviceTokenApplePushVoIP)
      if (COMPILE_CHECK) {
        DeviceTokenApplePushVoIP(
          this.deviceToken,
          this.isAppSandbox,
          this.encrypt
        )
      }
      this.isAppSandbox == b.isAppSandbox &&
      this.encrypt == b.encrypt &&
      this.deviceToken.equalsOrEmpty(b.deviceToken)
    }
    DeviceTokenBlackBerryPush.CONSTRUCTOR -> {
      require(this is DeviceTokenBlackBerryPush && b is DeviceTokenBlackBerryPush)
      if (COMPILE_CHECK) {
        DeviceTokenBlackBerryPush(
          this.token
        )
      }
      this.token.equalsOrEmpty(b.token)
    }
    DeviceTokenFirebaseCloudMessaging.CONSTRUCTOR -> {
      require(this is DeviceTokenFirebaseCloudMessaging && b is DeviceTokenFirebaseCloudMessaging)
      if (COMPILE_CHECK) {
        DeviceTokenFirebaseCloudMessaging(
          this.token,
          this.encrypt
        )
      }
      this.encrypt == b.encrypt &&
      this.token.equalsOrEmpty(b.token)
    }
    DeviceTokenHuaweiPush.CONSTRUCTOR -> {
      require(this is DeviceTokenHuaweiPush && b is DeviceTokenHuaweiPush)
      if (COMPILE_CHECK) {
        DeviceTokenHuaweiPush(
          this.token,
          this.encrypt
        )
      }
      this.encrypt == b.encrypt &&
      this.token.equalsOrEmpty(b.token)
    }
    DeviceTokenMicrosoftPush.CONSTRUCTOR -> {
      require(this is DeviceTokenMicrosoftPush && b is DeviceTokenMicrosoftPush)
      if (COMPILE_CHECK) {
        DeviceTokenMicrosoftPush(
          this.channelUri
        )
      }
      this.channelUri.equalsOrEmpty(b.channelUri)
    }
    DeviceTokenMicrosoftPushVoIP.CONSTRUCTOR -> {
      require(this is DeviceTokenMicrosoftPushVoIP && b is DeviceTokenMicrosoftPushVoIP)
      if (COMPILE_CHECK) {
        DeviceTokenMicrosoftPushVoIP(
          this.channelUri
        )
      }
      this.channelUri.equalsOrEmpty(b.channelUri)
    }
    DeviceTokenSimplePush.CONSTRUCTOR -> {
      require(this is DeviceTokenSimplePush && b is DeviceTokenSimplePush)
      if (COMPILE_CHECK) {
        DeviceTokenSimplePush(
          this.endpoint
        )
      }
      this.endpoint.equalsOrEmpty(b.endpoint)
    }
    DeviceTokenTizenPush.CONSTRUCTOR -> {
      require(this is DeviceTokenTizenPush && b is DeviceTokenTizenPush)
      if (COMPILE_CHECK) {
        DeviceTokenTizenPush(
          this.regId
        )
      }
      this.regId.equalsOrEmpty(b.regId)
    }
    DeviceTokenUbuntuPush.CONSTRUCTOR -> {
      require(this is DeviceTokenUbuntuPush && b is DeviceTokenUbuntuPush)
      if (COMPILE_CHECK) {
        DeviceTokenUbuntuPush(
          this.token
        )
      }
      this.token.equalsOrEmpty(b.token)
    }
    DeviceTokenWebPush.CONSTRUCTOR -> {
      require(this is DeviceTokenWebPush && b is DeviceTokenWebPush)
      if (COMPILE_CHECK) {
        DeviceTokenWebPush(
          this.endpoint,
          this.p256dhBase64url,
          this.authBase64url
        )
      }
      this.endpoint.equalsOrEmpty(b.endpoint) &&
      this.p256dhBase64url.equalsOrEmpty(b.p256dhBase64url) &&
      this.authBase64url.equalsOrEmpty(b.authBase64url)
    }
    DeviceTokenWindowsPush.CONSTRUCTOR -> {
      require(this is DeviceTokenWindowsPush && b is DeviceTokenWindowsPush)
      if (COMPILE_CHECK) {
        DeviceTokenWindowsPush(
          this.accessToken
        )
      }
      this.accessToken.equalsOrEmpty(b.accessToken)
    }
    else -> {
      assertDeviceToken_de4a4f61()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun InlineKeyboardButtonType?.equalsTo(other: InlineKeyboardButtonType?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    InlineKeyboardButtonTypeBuy.CONSTRUCTOR,
    InlineKeyboardButtonTypeCallbackGame.CONSTRUCTOR ->
      true // nothing to compare
    InlineKeyboardButtonTypeCallback.CONSTRUCTOR -> {
      require(this is InlineKeyboardButtonTypeCallback && b is InlineKeyboardButtonTypeCallback)
      if (COMPILE_CHECK) {
        InlineKeyboardButtonTypeCallback(
          this.data
        )
      }
      this.data.contentEqualsOrEmpty(b.data)
    }
    InlineKeyboardButtonTypeCallbackWithPassword.CONSTRUCTOR -> {
      require(this is InlineKeyboardButtonTypeCallbackWithPassword && b is InlineKeyboardButtonTypeCallbackWithPassword)
      if (COMPILE_CHECK) {
        InlineKeyboardButtonTypeCallbackWithPassword(
          this.data
        )
      }
      this.data.contentEqualsOrEmpty(b.data)
    }
    InlineKeyboardButtonTypeCopyText.CONSTRUCTOR -> {
      require(this is InlineKeyboardButtonTypeCopyText && b is InlineKeyboardButtonTypeCopyText)
      if (COMPILE_CHECK) {
        InlineKeyboardButtonTypeCopyText(
          this.text
        )
      }
      this.text.equalsOrEmpty(b.text)
    }
    InlineKeyboardButtonTypeLoginUrl.CONSTRUCTOR -> {
      require(this is InlineKeyboardButtonTypeLoginUrl && b is InlineKeyboardButtonTypeLoginUrl)
      if (COMPILE_CHECK) {
        InlineKeyboardButtonTypeLoginUrl(
          this.url,
          this.id,
          this.forwardText
        )
      }
      this.id == b.id &&
      this.url.equalsOrEmpty(b.url) &&
      this.forwardText.equalsOrEmpty(b.forwardText)
    }
    InlineKeyboardButtonTypeSwitchInline.CONSTRUCTOR -> {
      require(this is InlineKeyboardButtonTypeSwitchInline && b is InlineKeyboardButtonTypeSwitchInline)
      if (COMPILE_CHECK) {
        InlineKeyboardButtonTypeSwitchInline(
          this.query,
          this.targetChat
        )
      }
      this.query.equalsOrEmpty(b.query) &&
      this.targetChat.equalsTo(b.targetChat)
    }
    InlineKeyboardButtonTypeUrl.CONSTRUCTOR -> {
      require(this is InlineKeyboardButtonTypeUrl && b is InlineKeyboardButtonTypeUrl)
      if (COMPILE_CHECK) {
        InlineKeyboardButtonTypeUrl(
          this.url
        )
      }
      this.url.equalsOrEmpty(b.url)
    }
    InlineKeyboardButtonTypeUser.CONSTRUCTOR -> {
      require(this is InlineKeyboardButtonTypeUser && b is InlineKeyboardButtonTypeUser)
      if (COMPILE_CHECK) {
        InlineKeyboardButtonTypeUser(
          this.userId
        )
      }
      this.userId == b.userId
    }
    InlineKeyboardButtonTypeWebApp.CONSTRUCTOR -> {
      require(this is InlineKeyboardButtonTypeWebApp && b is InlineKeyboardButtonTypeWebApp)
      if (COMPILE_CHECK) {
        InlineKeyboardButtonTypeWebApp(
          this.url
        )
      }
      this.url.equalsOrEmpty(b.url)
    }
    else -> {
      assertInlineKeyboardButtonType_4c981aa8()
      throw unsupported(this)
    }
  }
}

@OptIn(ExperimentalContracts::class)
@Autogenerated
fun InternalLinkType?.equalsTo(other: InternalLinkType?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    InternalLinkTypeActiveSessions.CONSTRUCTOR,
    InternalLinkTypeChangePhoneNumber.CONSTRUCTOR,
    InternalLinkTypeChatFolderSettings.CONSTRUCTOR,
    InternalLinkTypeDefaultMessageAutoDeleteTimerSettings.CONSTRUCTOR,
    InternalLinkTypeEditProfileSettings.CONSTRUCTOR,
    InternalLinkTypeLanguageSettings.CONSTRUCTOR,
    InternalLinkTypePrivacyAndSecuritySettings.CONSTRUCTOR,
    InternalLinkTypeQrCodeAuthentication.CONSTRUCTOR,
    InternalLinkTypeRestorePurchases.CONSTRUCTOR,
    InternalLinkTypeSettings.CONSTRUCTOR,
    InternalLinkTypeThemeSettings.CONSTRUCTOR,
    InternalLinkTypeUnsupportedProxy.CONSTRUCTOR ->
      true // nothing to compare
    InternalLinkTypeAttachmentMenuBot.CONSTRUCTOR -> {
      require(this is InternalLinkTypeAttachmentMenuBot && b is InternalLinkTypeAttachmentMenuBot)
      if (COMPILE_CHECK) {
        InternalLinkTypeAttachmentMenuBot(
          this.targetChat,
          this.botUsername,
          this.url
        )
      }
      this.targetChat.equalsTo(b.targetChat) &&
      this.botUsername.equalsOrEmpty(b.botUsername) &&
      this.url.equalsOrEmpty(b.url)
    }
    InternalLinkTypeAuthenticationCode.CONSTRUCTOR -> {
      require(this is InternalLinkTypeAuthenticationCode && b is InternalLinkTypeAuthenticationCode)
      if (COMPILE_CHECK) {
        InternalLinkTypeAuthenticationCode(
          this.code
        )
      }
      this.code.equalsOrEmpty(b.code)
    }
    InternalLinkTypeBackground.CONSTRUCTOR -> {
      require(this is InternalLinkTypeBackground && b is InternalLinkTypeBackground)
      if (COMPILE_CHECK) {
        InternalLinkTypeBackground(
          this.backgroundName
        )
      }
      this.backgroundName.equalsOrEmpty(b.backgroundName)
    }
    InternalLinkTypeBotAddToChannel.CONSTRUCTOR -> {
      require(this is InternalLinkTypeBotAddToChannel && b is InternalLinkTypeBotAddToChannel)
      if (COMPILE_CHECK) {
        InternalLinkTypeBotAddToChannel(
          this.botUsername,
          this.administratorRights
        )
      }
      this.botUsername.equalsOrEmpty(b.botUsername) &&
      this.administratorRights.equalsTo(b.administratorRights)
    }
    InternalLinkTypeBotStart.CONSTRUCTOR -> {
      require(this is InternalLinkTypeBotStart && b is InternalLinkTypeBotStart)
      if (COMPILE_CHECK) {
        InternalLinkTypeBotStart(
          this.botUsername,
          this.startParameter,
          this.autostart
        )
      }
      this.autostart == b.autostart &&
      this.botUsername.equalsOrEmpty(b.botUsername) &&
      this.startParameter.equalsOrEmpty(b.startParameter)
    }
    InternalLinkTypeBotStartInGroup.CONSTRUCTOR -> {
      require(this is InternalLinkTypeBotStartInGroup && b is InternalLinkTypeBotStartInGroup)
      if (COMPILE_CHECK) {
        InternalLinkTypeBotStartInGroup(
          this.botUsername,
          this.startParameter,
          this.administratorRights
        )
      }
      this.botUsername.equalsOrEmpty(b.botUsername) &&
      this.startParameter.equalsOrEmpty(b.startParameter) &&
      this.administratorRights.equalsTo(b.administratorRights)
    }
    InternalLinkTypeBusinessChat.CONSTRUCTOR -> {
      require(this is InternalLinkTypeBusinessChat && b is InternalLinkTypeBusinessChat)
      if (COMPILE_CHECK) {
        InternalLinkTypeBusinessChat(
          this.linkName
        )
      }
      this.linkName.equalsOrEmpty(b.linkName)
    }
    InternalLinkTypeBuyStars.CONSTRUCTOR -> {
      require(this is InternalLinkTypeBuyStars && b is InternalLinkTypeBuyStars)
      if (COMPILE_CHECK) {
        InternalLinkTypeBuyStars(
          this.starCount,
          this.purpose
        )
      }
      this.starCount == b.starCount &&
      this.purpose.equalsOrEmpty(b.purpose)
    }
    InternalLinkTypeChatAffiliateProgram.CONSTRUCTOR -> {
      require(this is InternalLinkTypeChatAffiliateProgram && b is InternalLinkTypeChatAffiliateProgram)
      if (COMPILE_CHECK) {
        InternalLinkTypeChatAffiliateProgram(
          this.username,
          this.referrer
        )
      }
      this.username.equalsOrEmpty(b.username) &&
      this.referrer.equalsOrEmpty(b.referrer)
    }
    InternalLinkTypeChatBoost.CONSTRUCTOR -> {
      require(this is InternalLinkTypeChatBoost && b is InternalLinkTypeChatBoost)
      if (COMPILE_CHECK) {
        InternalLinkTypeChatBoost(
          this.url
        )
      }
      this.url.equalsOrEmpty(b.url)
    }
    InternalLinkTypeChatFolderInvite.CONSTRUCTOR -> {
      require(this is InternalLinkTypeChatFolderInvite && b is InternalLinkTypeChatFolderInvite)
      if (COMPILE_CHECK) {
        InternalLinkTypeChatFolderInvite(
          this.inviteLink
        )
      }
      this.inviteLink.equalsOrEmpty(b.inviteLink)
    }
    InternalLinkTypeChatInvite.CONSTRUCTOR -> {
      require(this is InternalLinkTypeChatInvite && b is InternalLinkTypeChatInvite)
      if (COMPILE_CHECK) {
        InternalLinkTypeChatInvite(
          this.inviteLink
        )
      }
      this.inviteLink.equalsOrEmpty(b.inviteLink)
    }
    InternalLinkTypeGame.CONSTRUCTOR -> {
      require(this is InternalLinkTypeGame && b is InternalLinkTypeGame)
      if (COMPILE_CHECK) {
        InternalLinkTypeGame(
          this.botUsername,
          this.gameShortName
        )
      }
      this.botUsername.equalsOrEmpty(b.botUsername) &&
      this.gameShortName.equalsOrEmpty(b.gameShortName)
    }
    InternalLinkTypeInstantView.CONSTRUCTOR -> {
      require(this is InternalLinkTypeInstantView && b is InternalLinkTypeInstantView)
      if (COMPILE_CHECK) {
        InternalLinkTypeInstantView(
          this.url,
          this.fallbackUrl
        )
      }
      this.url.equalsOrEmpty(b.url) &&
      this.fallbackUrl.equalsOrEmpty(b.fallbackUrl)
    }
    InternalLinkTypeInvoice.CONSTRUCTOR -> {
      require(this is InternalLinkTypeInvoice && b is InternalLinkTypeInvoice)
      if (COMPILE_CHECK) {
        InternalLinkTypeInvoice(
          this.invoiceName
        )
      }
      this.invoiceName.equalsOrEmpty(b.invoiceName)
    }
    InternalLinkTypeLanguagePack.CONSTRUCTOR -> {
      require(this is InternalLinkTypeLanguagePack && b is InternalLinkTypeLanguagePack)
      if (COMPILE_CHECK) {
        InternalLinkTypeLanguagePack(
          this.languagePackId
        )
      }
      this.languagePackId.equalsOrEmpty(b.languagePackId)
    }
    InternalLinkTypeMainWebApp.CONSTRUCTOR -> {
      require(this is InternalLinkTypeMainWebApp && b is InternalLinkTypeMainWebApp)
      if (COMPILE_CHECK) {
        InternalLinkTypeMainWebApp(
          this.botUsername,
          this.startParameter,
          this.mode
        )
      }
      this.botUsername.equalsOrEmpty(b.botUsername) &&
      this.startParameter.equalsOrEmpty(b.startParameter) &&
      this.mode.equalsTo(b.mode)
    }
    InternalLinkTypeMessage.CONSTRUCTOR -> {
      require(this is InternalLinkTypeMessage && b is InternalLinkTypeMessage)
      if (COMPILE_CHECK) {
        InternalLinkTypeMessage(
          this.url
        )
      }
      this.url.equalsOrEmpty(b.url)
    }
    InternalLinkTypeMessageDraft.CONSTRUCTOR -> {
      require(this is InternalLinkTypeMessageDraft && b is InternalLinkTypeMessageDraft)
      if (COMPILE_CHECK) {
        InternalLinkTypeMessageDraft(
          this.text,
          this.containsLink
        )
      }
      this.containsLink == b.containsLink &&
      this.text.equalsTo(b.text)
    }
    InternalLinkTypePassportDataRequest.CONSTRUCTOR -> {
      require(this is InternalLinkTypePassportDataRequest && b is InternalLinkTypePassportDataRequest)
      if (COMPILE_CHECK) {
        InternalLinkTypePassportDataRequest(
          this.botUserId,
          this.scope,
          this.publicKey,
          this.nonce,
          this.callbackUrl
        )
      }
      this.botUserId == b.botUserId &&
      this.scope.equalsOrEmpty(b.scope) &&
      this.publicKey.equalsOrEmpty(b.publicKey) &&
      this.nonce.equalsOrEmpty(b.nonce) &&
      this.callbackUrl.equalsOrEmpty(b.callbackUrl)
    }
    InternalLinkTypePhoneNumberConfirmation.CONSTRUCTOR -> {
      require(this is InternalLinkTypePhoneNumberConfirmation && b is InternalLinkTypePhoneNumberConfirmation)
      if (COMPILE_CHECK) {
        InternalLinkTypePhoneNumberConfirmation(
          this.hash,
          this.phoneNumber
        )
      }
      this.hash.equalsOrEmpty(b.hash) &&
      this.phoneNumber.equalsOrEmpty(b.phoneNumber)
    }
    InternalLinkTypePremiumFeatures.CONSTRUCTOR -> {
      require(this is InternalLinkTypePremiumFeatures && b is InternalLinkTypePremiumFeatures)
      if (COMPILE_CHECK) {
        InternalLinkTypePremiumFeatures(
          this.referrer
        )
      }
      this.referrer.equalsOrEmpty(b.referrer)
    }
    InternalLinkTypePremiumGift.CONSTRUCTOR -> {
      require(this is InternalLinkTypePremiumGift && b is InternalLinkTypePremiumGift)
      if (COMPILE_CHECK) {
        InternalLinkTypePremiumGift(
          this.referrer
        )
      }
      this.referrer.equalsOrEmpty(b.referrer)
    }
    InternalLinkTypePremiumGiftCode.CONSTRUCTOR -> {
      require(this is InternalLinkTypePremiumGiftCode && b is InternalLinkTypePremiumGiftCode)
      if (COMPILE_CHECK) {
        InternalLinkTypePremiumGiftCode(
          this.code
        )
      }
      this.code.equalsOrEmpty(b.code)
    }
    InternalLinkTypeProxy.CONSTRUCTOR -> {
      require(this is InternalLinkTypeProxy && b is InternalLinkTypeProxy)
      if (COMPILE_CHECK) {
        InternalLinkTypeProxy(
          this.server,
          this.port,
          this.type
        )
      }
      this.port == b.port &&
      this.server.equalsOrEmpty(b.server) &&
      this.type.equalsTo(b.type)
    }
    InternalLinkTypePublicChat.CONSTRUCTOR -> {
      require(this is InternalLinkTypePublicChat && b is InternalLinkTypePublicChat)
      if (COMPILE_CHECK) {
        InternalLinkTypePublicChat(
          this.chatUsername,
          this.draftText,
          this.openProfile
        )
      }
      this.openProfile == b.openProfile &&
      this.chatUsername.equalsOrEmpty(b.chatUsername) &&
      this.draftText.equalsOrEmpty(b.draftText)
    }
    InternalLinkTypeStickerSet.CONSTRUCTOR -> {
      require(this is InternalLinkTypeStickerSet && b is InternalLinkTypeStickerSet)
      if (COMPILE_CHECK) {
        InternalLinkTypeStickerSet(
          this.stickerSetName,
          this.expectCustomEmoji
        )
      }
      this.expectCustomEmoji == b.expectCustomEmoji &&
      this.stickerSetName.equalsOrEmpty(b.stickerSetName)
    }
    InternalLinkTypeStory.CONSTRUCTOR -> {
      require(this is InternalLinkTypeStory && b is InternalLinkTypeStory)
      if (COMPILE_CHECK) {
        InternalLinkTypeStory(
          this.storySenderUsername,
          this.storyId
        )
      }
      this.storyId == b.storyId &&
      this.storySenderUsername.equalsOrEmpty(b.storySenderUsername)
    }
    InternalLinkTypeTheme.CONSTRUCTOR -> {
      require(this is InternalLinkTypeTheme && b is InternalLinkTypeTheme)
      if (COMPILE_CHECK) {
        InternalLinkTypeTheme(
          this.themeName
        )
      }
      this.themeName.equalsOrEmpty(b.themeName)
    }
    InternalLinkTypeUnknownDeepLink.CONSTRUCTOR -> {
      require(this is InternalLinkTypeUnknownDeepLink && b is InternalLinkTypeUnknownDeepLink)
      if (COMPILE_CHECK) {
        InternalLinkTypeUnknownDeepLink(
          this.link
        )
      }
      this.link.equalsOrEmpty(b.link)
    }
    InternalLinkTypeUpgradedGift.CONSTRUCTOR -> {
      require(this is InternalLinkTypeUpgradedGift && b is InternalLinkTypeUpgradedGift)
      if (COMPILE_CHECK) {
        InternalLinkTypeUpgradedGift(
          this.name
        )
      }
      this.name.equalsOrEmpty(b.name)
    }
    InternalLinkTypeUserPhoneNumber.CONSTRUCTOR -> {
      require(this is InternalLinkTypeUserPhoneNumber && b is InternalLinkTypeUserPhoneNumber)
      if (COMPILE_CHECK) {
        InternalLinkTypeUserPhoneNumber(
          this.phoneNumber,
          this.draftText,
          this.openProfile
        )
      }
      this.openProfile == b.openProfile &&
      this.phoneNumber.equalsOrEmpty(b.phoneNumber) &&
      this.draftText.equalsOrEmpty(b.draftText)
    }
    InternalLinkTypeUserToken.CONSTRUCTOR -> {
      require(this is InternalLinkTypeUserToken && b is InternalLinkTypeUserToken)
      if (COMPILE_CHECK) {
        InternalLinkTypeUserToken(
          this.token
        )
      }
      this.token.equalsOrEmpty(b.token)
    }
    InternalLinkTypeVideoChat.CONSTRUCTOR -> {
      require(this is InternalLinkTypeVideoChat && b is InternalLinkTypeVideoChat)
      if (COMPILE_CHECK) {
        InternalLinkTypeVideoChat(
          this.chatUsername,
          this.inviteHash,
          this.isLiveStream
        )
      }
      this.isLiveStream == b.isLiveStream &&
      this.chatUsername.equalsOrEmpty(b.chatUsername) &&
      this.inviteHash.equalsOrEmpty(b.inviteHash)
    }
    InternalLinkTypeWebApp.CONSTRUCTOR -> {
      require(this is InternalLinkTypeWebApp && b is InternalLinkTypeWebApp)
      if (COMPILE_CHECK) {
        InternalLinkTypeWebApp(
          this.botUsername,
          this.webAppShortName,
          this.startParameter,
          this.mode
        )
      }
      this.botUsername.equalsOrEmpty(b.botUsername) &&
      this.webAppShortName.equalsOrEmpty(b.webAppShortName) &&
      this.startParameter.equalsOrEmpty(b.startParameter) &&
      this.mode.equalsTo(b.mode)
    }
    else -> {
      assertInternalLinkType_5626dbbe()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun InviteLinkChatType?.equalsTo(other: InviteLinkChatType?): Boolean = this.safeEqualsTo(other) { _ ->
  when (this.constructor) {
    InviteLinkChatTypeBasicGroup.CONSTRUCTOR,
    InviteLinkChatTypeChannel.CONSTRUCTOR,
    InviteLinkChatTypeSupergroup.CONSTRUCTOR ->
      true // nothing to compare
    else -> {
      assertInviteLinkChatType_5c8a8927()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun KeyboardButtonType?.equalsTo(other: KeyboardButtonType?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    KeyboardButtonTypeRequestLocation.CONSTRUCTOR,
    KeyboardButtonTypeRequestPhoneNumber.CONSTRUCTOR,
    KeyboardButtonTypeText.CONSTRUCTOR ->
      true // nothing to compare
    KeyboardButtonTypeRequestChat.CONSTRUCTOR -> {
      require(this is KeyboardButtonTypeRequestChat && b is KeyboardButtonTypeRequestChat)
      if (COMPILE_CHECK) {
        KeyboardButtonTypeRequestChat(
          this.id,
          this.chatIsChannel,
          this.restrictChatIsForum,
          this.chatIsForum,
          this.restrictChatHasUsername,
          this.chatHasUsername,
          this.chatIsCreated,
          this.userAdministratorRights,
          this.botAdministratorRights,
          this.botIsMember,
          this.requestTitle,
          this.requestUsername,
          this.requestPhoto
        )
      }
      this.id == b.id &&
      this.chatIsChannel == b.chatIsChannel &&
      this.restrictChatIsForum == b.restrictChatIsForum &&
      this.chatIsForum == b.chatIsForum &&
      this.restrictChatHasUsername == b.restrictChatHasUsername &&
      this.chatHasUsername == b.chatHasUsername &&
      this.chatIsCreated == b.chatIsCreated &&
      this.botIsMember == b.botIsMember &&
      this.requestTitle == b.requestTitle &&
      this.requestUsername == b.requestUsername &&
      this.requestPhoto == b.requestPhoto &&
      this.userAdministratorRights.equalsTo(b.userAdministratorRights) &&
      this.botAdministratorRights.equalsTo(b.botAdministratorRights)
    }
    KeyboardButtonTypeRequestPoll.CONSTRUCTOR -> {
      require(this is KeyboardButtonTypeRequestPoll && b is KeyboardButtonTypeRequestPoll)
      if (COMPILE_CHECK) {
        KeyboardButtonTypeRequestPoll(
          this.forceRegular,
          this.forceQuiz
        )
      }
      this.forceRegular == b.forceRegular &&
      this.forceQuiz == b.forceQuiz
    }
    KeyboardButtonTypeRequestUsers.CONSTRUCTOR -> {
      require(this is KeyboardButtonTypeRequestUsers && b is KeyboardButtonTypeRequestUsers)
      if (COMPILE_CHECK) {
        KeyboardButtonTypeRequestUsers(
          this.id,
          this.restrictUserIsBot,
          this.userIsBot,
          this.restrictUserIsPremium,
          this.userIsPremium,
          this.maxQuantity,
          this.requestName,
          this.requestUsername,
          this.requestPhoto
        )
      }
      this.id == b.id &&
      this.restrictUserIsBot == b.restrictUserIsBot &&
      this.userIsBot == b.userIsBot &&
      this.restrictUserIsPremium == b.restrictUserIsPremium &&
      this.userIsPremium == b.userIsPremium &&
      this.maxQuantity == b.maxQuantity &&
      this.requestName == b.requestName &&
      this.requestUsername == b.requestUsername &&
      this.requestPhoto == b.requestPhoto
    }
    KeyboardButtonTypeWebApp.CONSTRUCTOR -> {
      require(this is KeyboardButtonTypeWebApp && b is KeyboardButtonTypeWebApp)
      if (COMPILE_CHECK) {
        KeyboardButtonTypeWebApp(
          this.url
        )
      }
      this.url.equalsOrEmpty(b.url)
    }
    else -> {
      assertKeyboardButtonType_b955a01e()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun LinkPreviewAlbumMedia?.equalsTo(other: LinkPreviewAlbumMedia?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    LinkPreviewAlbumMediaPhoto.CONSTRUCTOR -> {
      require(this is LinkPreviewAlbumMediaPhoto && b is LinkPreviewAlbumMediaPhoto)
      if (COMPILE_CHECK) {
        LinkPreviewAlbumMediaPhoto(
          this.photo
        )
      }
      this.photo.equalsTo(b.photo)
    }
    LinkPreviewAlbumMediaVideo.CONSTRUCTOR -> {
      require(this is LinkPreviewAlbumMediaVideo && b is LinkPreviewAlbumMediaVideo)
      if (COMPILE_CHECK) {
        LinkPreviewAlbumMediaVideo(
          this.video
        )
      }
      this.video.equalsTo(b.video)
    }
    else -> {
      assertLinkPreviewAlbumMedia_8c33c943()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun LinkPreviewType?.equalsTo(other: LinkPreviewType?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    LinkPreviewTypeInvoice.CONSTRUCTOR,
    LinkPreviewTypeMessage.CONSTRUCTOR,
    LinkPreviewTypePremiumGiftCode.CONSTRUCTOR,
    LinkPreviewTypeShareableChatFolder.CONSTRUCTOR,
    LinkPreviewTypeUnsupported.CONSTRUCTOR ->
      true // nothing to compare
    LinkPreviewTypeAlbum.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeAlbum && b is LinkPreviewTypeAlbum)
      if (COMPILE_CHECK) {
        LinkPreviewTypeAlbum(
          this.media,
          this.caption
        )
      }
      this.media.equalsTo(b.media) &&
      this.caption.equalsOrEmpty(b.caption)
    }
    LinkPreviewTypeAnimation.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeAnimation && b is LinkPreviewTypeAnimation)
      if (COMPILE_CHECK) {
        LinkPreviewTypeAnimation(
          this.animation
        )
      }
      this.animation.equalsTo(b.animation)
    }
    LinkPreviewTypeApp.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeApp && b is LinkPreviewTypeApp)
      if (COMPILE_CHECK) {
        LinkPreviewTypeApp(
          this.photo
        )
      }
      this.photo.equalsTo(b.photo)
    }
    LinkPreviewTypeArticle.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeArticle && b is LinkPreviewTypeArticle)
      if (COMPILE_CHECK) {
        LinkPreviewTypeArticle(
          this.photo
        )
      }
      this.photo.equalsTo(b.photo)
    }
    LinkPreviewTypeAudio.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeAudio && b is LinkPreviewTypeAudio)
      if (COMPILE_CHECK) {
        LinkPreviewTypeAudio(
          this.audio
        )
      }
      this.audio.equalsTo(b.audio)
    }
    LinkPreviewTypeBackground.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeBackground && b is LinkPreviewTypeBackground)
      if (COMPILE_CHECK) {
        LinkPreviewTypeBackground(
          this.document,
          this.backgroundType
        )
      }
      this.document.equalsTo(b.document) &&
      this.backgroundType.equalsTo(b.backgroundType)
    }
    LinkPreviewTypeChannelBoost.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeChannelBoost && b is LinkPreviewTypeChannelBoost)
      if (COMPILE_CHECK) {
        LinkPreviewTypeChannelBoost(
          this.photo
        )
      }
      this.photo.equalsTo(b.photo)
    }
    LinkPreviewTypeChat.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeChat && b is LinkPreviewTypeChat)
      if (COMPILE_CHECK) {
        LinkPreviewTypeChat(
          this.type,
          this.photo,
          this.createsJoinRequest
        )
      }
      this.createsJoinRequest == b.createsJoinRequest &&
      this.type.equalsTo(b.type) &&
      this.photo.equalsTo(b.photo)
    }
    LinkPreviewTypeDocument.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeDocument && b is LinkPreviewTypeDocument)
      if (COMPILE_CHECK) {
        LinkPreviewTypeDocument(
          this.document
        )
      }
      this.document.equalsTo(b.document)
    }
    LinkPreviewTypeEmbeddedAnimationPlayer.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeEmbeddedAnimationPlayer && b is LinkPreviewTypeEmbeddedAnimationPlayer)
      if (COMPILE_CHECK) {
        LinkPreviewTypeEmbeddedAnimationPlayer(
          this.url,
          this.thumbnail,
          this.duration,
          this.width,
          this.height
        )
      }
      this.duration == b.duration &&
      this.width == b.width &&
      this.height == b.height &&
      this.url.equalsOrEmpty(b.url) &&
      this.thumbnail.equalsTo(b.thumbnail)
    }
    LinkPreviewTypeEmbeddedAudioPlayer.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeEmbeddedAudioPlayer && b is LinkPreviewTypeEmbeddedAudioPlayer)
      if (COMPILE_CHECK) {
        LinkPreviewTypeEmbeddedAudioPlayer(
          this.url,
          this.thumbnail,
          this.duration,
          this.width,
          this.height
        )
      }
      this.duration == b.duration &&
      this.width == b.width &&
      this.height == b.height &&
      this.url.equalsOrEmpty(b.url) &&
      this.thumbnail.equalsTo(b.thumbnail)
    }
    LinkPreviewTypeEmbeddedVideoPlayer.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeEmbeddedVideoPlayer && b is LinkPreviewTypeEmbeddedVideoPlayer)
      if (COMPILE_CHECK) {
        LinkPreviewTypeEmbeddedVideoPlayer(
          this.url,
          this.thumbnail,
          this.duration,
          this.width,
          this.height
        )
      }
      this.duration == b.duration &&
      this.width == b.width &&
      this.height == b.height &&
      this.url.equalsOrEmpty(b.url) &&
      this.thumbnail.equalsTo(b.thumbnail)
    }
    LinkPreviewTypeExternalAudio.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeExternalAudio && b is LinkPreviewTypeExternalAudio)
      if (COMPILE_CHECK) {
        LinkPreviewTypeExternalAudio(
          this.url,
          this.mimeType,
          this.duration
        )
      }
      this.duration == b.duration &&
      this.url.equalsOrEmpty(b.url) &&
      this.mimeType.equalsOrEmpty(b.mimeType)
    }
    LinkPreviewTypeExternalVideo.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeExternalVideo && b is LinkPreviewTypeExternalVideo)
      if (COMPILE_CHECK) {
        LinkPreviewTypeExternalVideo(
          this.url,
          this.mimeType,
          this.width,
          this.height,
          this.duration
        )
      }
      this.width == b.width &&
      this.height == b.height &&
      this.duration == b.duration &&
      this.url.equalsOrEmpty(b.url) &&
      this.mimeType.equalsOrEmpty(b.mimeType)
    }
    LinkPreviewTypePhoto.CONSTRUCTOR -> {
      require(this is LinkPreviewTypePhoto && b is LinkPreviewTypePhoto)
      if (COMPILE_CHECK) {
        LinkPreviewTypePhoto(
          this.photo
        )
      }
      this.photo.equalsTo(b.photo)
    }
    LinkPreviewTypeSticker.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeSticker && b is LinkPreviewTypeSticker)
      if (COMPILE_CHECK) {
        LinkPreviewTypeSticker(
          this.sticker
        )
      }
      this.sticker.equalsTo(b.sticker)
    }
    LinkPreviewTypeStickerSet.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeStickerSet && b is LinkPreviewTypeStickerSet)
      if (COMPILE_CHECK) {
        LinkPreviewTypeStickerSet(
          this.stickers
        )
      }
      this.stickers.equalsTo(b.stickers)
    }
    LinkPreviewTypeStory.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeStory && b is LinkPreviewTypeStory)
      if (COMPILE_CHECK) {
        LinkPreviewTypeStory(
          this.storySenderChatId,
          this.storyId
        )
      }
      this.storySenderChatId == b.storySenderChatId &&
      this.storyId == b.storyId
    }
    LinkPreviewTypeSupergroupBoost.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeSupergroupBoost && b is LinkPreviewTypeSupergroupBoost)
      if (COMPILE_CHECK) {
        LinkPreviewTypeSupergroupBoost(
          this.photo
        )
      }
      this.photo.equalsTo(b.photo)
    }
    LinkPreviewTypeTheme.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeTheme && b is LinkPreviewTypeTheme)
      if (COMPILE_CHECK) {
        LinkPreviewTypeTheme(
          this.documents,
          this.settings
        )
      }
      this.documents.equalsTo(b.documents) &&
      this.settings.equalsTo(b.settings)
    }
    LinkPreviewTypeUpgradedGift.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeUpgradedGift && b is LinkPreviewTypeUpgradedGift)
      if (COMPILE_CHECK) {
        LinkPreviewTypeUpgradedGift(
          this.gift
        )
      }
      this.gift.equalsTo(b.gift)
    }
    LinkPreviewTypeUser.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeUser && b is LinkPreviewTypeUser)
      if (COMPILE_CHECK) {
        LinkPreviewTypeUser(
          this.photo,
          this.isBot
        )
      }
      this.isBot == b.isBot &&
      this.photo.equalsTo(b.photo)
    }
    LinkPreviewTypeVideo.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeVideo && b is LinkPreviewTypeVideo)
      if (COMPILE_CHECK) {
        LinkPreviewTypeVideo(
          this.video,
          this.cover,
          this.startTimestamp
        )
      }
      this.startTimestamp == b.startTimestamp &&
      this.video.equalsTo(b.video) &&
      this.cover.equalsTo(b.cover)
    }
    LinkPreviewTypeVideoChat.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeVideoChat && b is LinkPreviewTypeVideoChat)
      if (COMPILE_CHECK) {
        LinkPreviewTypeVideoChat(
          this.photo,
          this.isLiveStream
        )
      }
      this.isLiveStream == b.isLiveStream &&
      this.photo.equalsTo(b.photo)
    }
    LinkPreviewTypeVideoNote.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeVideoNote && b is LinkPreviewTypeVideoNote)
      if (COMPILE_CHECK) {
        LinkPreviewTypeVideoNote(
          this.videoNote
        )
      }
      this.videoNote.equalsTo(b.videoNote)
    }
    LinkPreviewTypeVoiceNote.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeVoiceNote && b is LinkPreviewTypeVoiceNote)
      if (COMPILE_CHECK) {
        LinkPreviewTypeVoiceNote(
          this.voiceNote
        )
      }
      this.voiceNote.equalsTo(b.voiceNote)
    }
    LinkPreviewTypeWebApp.CONSTRUCTOR -> {
      require(this is LinkPreviewTypeWebApp && b is LinkPreviewTypeWebApp)
      if (COMPILE_CHECK) {
        LinkPreviewTypeWebApp(
          this.photo
        )
      }
      this.photo.equalsTo(b.photo)
    }
    else -> {
      assertLinkPreviewType_e4d80559()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun MaskPoint?.equalsTo(other: MaskPoint?): Boolean = this.safeEqualsTo(other) { _ ->
  when (this.constructor) {
    MaskPointChin.CONSTRUCTOR,
    MaskPointEyes.CONSTRUCTOR,
    MaskPointForehead.CONSTRUCTOR,
    MaskPointMouth.CONSTRUCTOR ->
      true // nothing to compare
    else -> {
      assertMaskPoint_40914d4e()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun MessageReplyTo?.equalsTo(other: MessageReplyTo?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    MessageReplyToMessage.CONSTRUCTOR -> {
      require(this is MessageReplyToMessage && b is MessageReplyToMessage)
      if (COMPILE_CHECK) {
        MessageReplyToMessage(
          this.chatId,
          this.messageId,
          this.quote,
          this.origin,
          this.originSendDate,
          this.content
        )
      }
      this.chatId == b.chatId &&
      this.messageId == b.messageId
      // ignored: this.quote.equalsTo(b.quote)
      // ignored: this.origin.equalsTo(b.origin)
      // ignored: this.originSendDate == b.originSendDate
      // ignored: this.content.equalsTo(b.content)
    }
    MessageReplyToStory.CONSTRUCTOR -> {
      require(this is MessageReplyToStory && b is MessageReplyToStory)
      if (COMPILE_CHECK) {
        MessageReplyToStory(
          this.storySenderChatId,
          this.storyId
        )
      }
      this.storySenderChatId == b.storySenderChatId &&
      this.storyId == b.storyId
    }
    else -> {
      assertMessageReplyTo_699c5345()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun MessageSelfDestructType?.equalsTo(other: MessageSelfDestructType?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    MessageSelfDestructTypeImmediately.CONSTRUCTOR ->
      true // nothing to compare
    MessageSelfDestructTypeTimer.CONSTRUCTOR -> {
      require(this is MessageSelfDestructTypeTimer && b is MessageSelfDestructTypeTimer)
      if (COMPILE_CHECK) {
        MessageSelfDestructTypeTimer(
          this.selfDestructTime
        )
      }
      this.selfDestructTime == b.selfDestructTime
    }
    else -> {
      assertMessageSelfDestructType_58882d8c()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun MessageSender?.equalsTo(other: MessageSender?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    MessageSenderChat.CONSTRUCTOR -> {
      require(this is MessageSenderChat && b is MessageSenderChat)
      if (COMPILE_CHECK) {
        MessageSenderChat(
          this.chatId
        )
      }
      this.chatId == b.chatId
    }
    MessageSenderUser.CONSTRUCTOR -> {
      require(this is MessageSenderUser && b is MessageSenderUser)
      if (COMPILE_CHECK) {
        MessageSenderUser(
          this.userId
        )
      }
      this.userId == b.userId
    }
    else -> {
      assertMessageSender_439d4c9c()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun OptionValue?.equalsTo(other: OptionValue?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    OptionValueEmpty.CONSTRUCTOR ->
      true // nothing to compare
    OptionValueBoolean.CONSTRUCTOR -> {
      require(this is OptionValueBoolean && b is OptionValueBoolean)
      if (COMPILE_CHECK) {
        OptionValueBoolean(
          this.value
        )
      }
      this.value == b.value
    }
    OptionValueInteger.CONSTRUCTOR -> {
      require(this is OptionValueInteger && b is OptionValueInteger)
      if (COMPILE_CHECK) {
        OptionValueInteger(
          this.value
        )
      }
      this.value == b.value
    }
    OptionValueString.CONSTRUCTOR -> {
      require(this is OptionValueString && b is OptionValueString)
      if (COMPILE_CHECK) {
        OptionValueString(
          this.value
        )
      }
      this.value.equalsOrEmpty(b.value)
    }
    else -> {
      assertOptionValue_710db1a4()
      throw unsupported(this)
    }
  }
}

@OptIn(ExperimentalContracts::class)
@Autogenerated
fun PollType?.equalsTo(other: PollType?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    PollTypeQuiz.CONSTRUCTOR -> {
      require(this is PollTypeQuiz && b is PollTypeQuiz)
      if (COMPILE_CHECK) {
        PollTypeQuiz(
          this.correctOptionId,
          this.explanation
        )
      }
      this.correctOptionId == b.correctOptionId &&
      this.explanation.equalsTo(b.explanation)
    }
    PollTypeRegular.CONSTRUCTOR -> {
      require(this is PollTypeRegular && b is PollTypeRegular)
      if (COMPILE_CHECK) {
        PollTypeRegular(
          this.allowMultipleAnswers
        )
      }
      this.allowMultipleAnswers == b.allowMultipleAnswers
    }
    else -> {
      assertPollType_324514f9()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun ProxyType?.equalsTo(other: ProxyType?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    ProxyTypeHttp.CONSTRUCTOR -> {
      require(this is ProxyTypeHttp && b is ProxyTypeHttp)
      if (COMPILE_CHECK) {
        ProxyTypeHttp(
          this.username,
          this.password,
          this.httpOnly
        )
      }
      this.httpOnly == b.httpOnly &&
      this.username.equalsOrEmpty(b.username) &&
      this.password.equalsOrEmpty(b.password)
    }
    ProxyTypeMtproto.CONSTRUCTOR -> {
      require(this is ProxyTypeMtproto && b is ProxyTypeMtproto)
      if (COMPILE_CHECK) {
        ProxyTypeMtproto(
          this.secret
        )
      }
      this.secret.equalsOrEmpty(b.secret)
    }
    ProxyTypeSocks5.CONSTRUCTOR -> {
      require(this is ProxyTypeSocks5 && b is ProxyTypeSocks5)
      if (COMPILE_CHECK) {
        ProxyTypeSocks5(
          this.username,
          this.password
        )
      }
      this.username.equalsOrEmpty(b.username) &&
      this.password.equalsOrEmpty(b.password)
    }
    else -> {
      assertProxyType_bc1a1076()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun ReactionType?.equalsTo(other: ReactionType?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    ReactionTypePaid.CONSTRUCTOR ->
      true // nothing to compare
    ReactionTypeCustomEmoji.CONSTRUCTOR -> {
      require(this is ReactionTypeCustomEmoji && b is ReactionTypeCustomEmoji)
      if (COMPILE_CHECK) {
        ReactionTypeCustomEmoji(
          this.customEmojiId
        )
      }
      this.customEmojiId == b.customEmojiId
    }
    ReactionTypeEmoji.CONSTRUCTOR -> {
      require(this is ReactionTypeEmoji && b is ReactionTypeEmoji)
      if (COMPILE_CHECK) {
        ReactionTypeEmoji(
          this.emoji
        )
      }
      this.emoji.equalsOrEmpty(b.emoji)
    }
    else -> {
      assertReactionType_43844388()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun ReplyMarkup?.equalsTo(other: ReplyMarkup?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    ReplyMarkupForceReply.CONSTRUCTOR -> {
      require(this is ReplyMarkupForceReply && b is ReplyMarkupForceReply)
      if (COMPILE_CHECK) {
        ReplyMarkupForceReply(
          this.isPersonal,
          this.inputFieldPlaceholder
        )
      }
      this.isPersonal == b.isPersonal &&
      this.inputFieldPlaceholder.equalsOrEmpty(b.inputFieldPlaceholder)
    }
    ReplyMarkupInlineKeyboard.CONSTRUCTOR -> {
      require(this is ReplyMarkupInlineKeyboard && b is ReplyMarkupInlineKeyboard)
      if (COMPILE_CHECK) {
        ReplyMarkupInlineKeyboard(
          this.rows
        )
      }
      this.rows.equalsTo(b.rows)
    }
    ReplyMarkupRemoveKeyboard.CONSTRUCTOR -> {
      require(this is ReplyMarkupRemoveKeyboard && b is ReplyMarkupRemoveKeyboard)
      if (COMPILE_CHECK) {
        ReplyMarkupRemoveKeyboard(
          this.isPersonal
        )
      }
      this.isPersonal == b.isPersonal
    }
    ReplyMarkupShowKeyboard.CONSTRUCTOR -> {
      require(this is ReplyMarkupShowKeyboard && b is ReplyMarkupShowKeyboard)
      if (COMPILE_CHECK) {
        ReplyMarkupShowKeyboard(
          this.rows,
          this.isPersistent,
          this.resizeKeyboard,
          this.oneTime,
          this.isPersonal,
          this.inputFieldPlaceholder
        )
      }
      this.isPersistent == b.isPersistent &&
      this.resizeKeyboard == b.resizeKeyboard &&
      this.oneTime == b.oneTime &&
      this.isPersonal == b.isPersonal &&
      this.rows.equalsTo(b.rows) &&
      this.inputFieldPlaceholder.equalsOrEmpty(b.inputFieldPlaceholder)
    }
    else -> {
      assertReplyMarkup_d6ebcdbe()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun SpeechRecognitionResult?.equalsTo(other: SpeechRecognitionResult?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    SpeechRecognitionResultError.CONSTRUCTOR -> {
      require(this is SpeechRecognitionResultError && b is SpeechRecognitionResultError)
      if (COMPILE_CHECK) {
        SpeechRecognitionResultError(
          this.error
        )
      }
      this.error.equalsTo(b.error)
    }
    SpeechRecognitionResultPending.CONSTRUCTOR -> {
      require(this is SpeechRecognitionResultPending && b is SpeechRecognitionResultPending)
      if (COMPILE_CHECK) {
        SpeechRecognitionResultPending(
          this.partialText
        )
      }
      this.partialText.equalsOrEmpty(b.partialText)
    }
    SpeechRecognitionResultText.CONSTRUCTOR -> {
      require(this is SpeechRecognitionResultText && b is SpeechRecognitionResultText)
      if (COMPILE_CHECK) {
        SpeechRecognitionResultText(
          this.text
        )
      }
      this.text.equalsOrEmpty(b.text)
    }
    else -> {
      assertSpeechRecognitionResult_537e9541()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun StickerFormat?.equalsTo(other: StickerFormat?): Boolean = this.safeEqualsTo(other) { _ ->
  when (this.constructor) {
    StickerFormatTgs.CONSTRUCTOR,
    StickerFormatWebm.CONSTRUCTOR,
    StickerFormatWebp.CONSTRUCTOR ->
      true // nothing to compare
    else -> {
      assertStickerFormat_4fea4648()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun StickerFullType?.equalsTo(other: StickerFullType?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    StickerFullTypeCustomEmoji.CONSTRUCTOR -> {
      require(this is StickerFullTypeCustomEmoji && b is StickerFullTypeCustomEmoji)
      if (COMPILE_CHECK) {
        StickerFullTypeCustomEmoji(
          this.customEmojiId,
          this.needsRepainting
        )
      }
      this.customEmojiId == b.customEmojiId &&
      this.needsRepainting == b.needsRepainting
    }
    StickerFullTypeMask.CONSTRUCTOR -> {
      require(this is StickerFullTypeMask && b is StickerFullTypeMask)
      if (COMPILE_CHECK) {
        StickerFullTypeMask(
          this.maskPosition
        )
      }
      this.maskPosition.equalsTo(b.maskPosition)
    }
    StickerFullTypeRegular.CONSTRUCTOR -> {
      require(this is StickerFullTypeRegular && b is StickerFullTypeRegular)
      if (COMPILE_CHECK) {
        StickerFullTypeRegular(
          this.premiumAnimation
        )
      }
      this.premiumAnimation.equalsTo(b.premiumAnimation)
    }
    else -> {
      assertStickerFullType_466eed9d()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun StickerType?.equalsTo(other: StickerType?): Boolean = this.safeEqualsTo(other) { _ ->
  when (this.constructor) {
    StickerTypeCustomEmoji.CONSTRUCTOR,
    StickerTypeMask.CONSTRUCTOR,
    StickerTypeRegular.CONSTRUCTOR ->
      true // nothing to compare
    else -> {
      assertStickerType_cc811bb7()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun StoryList?.equalsTo(other: StoryList?): Boolean = this.safeEqualsTo(other) { _ ->
  when (this.constructor) {
    StoryListArchive.CONSTRUCTOR,
    StoryListMain.CONSTRUCTOR ->
      true // nothing to compare
    else -> {
      assertStoryList_cf1e963()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun SuggestedAction?.equalsTo(other: SuggestedAction?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    SuggestedActionCheckPassword.CONSTRUCTOR,
    SuggestedActionCheckPhoneNumber.CONSTRUCTOR,
    SuggestedActionEnableArchiveAndMuteNewChats.CONSTRUCTOR,
    SuggestedActionExtendStarSubscriptions.CONSTRUCTOR,
    SuggestedActionGiftPremiumForChristmas.CONSTRUCTOR,
    SuggestedActionRestorePremium.CONSTRUCTOR,
    SuggestedActionSetBirthdate.CONSTRUCTOR,
    SuggestedActionSetProfilePhoto.CONSTRUCTOR,
    SuggestedActionSubscribeToAnnualPremium.CONSTRUCTOR,
    SuggestedActionUpgradePremium.CONSTRUCTOR,
    SuggestedActionViewChecksHint.CONSTRUCTOR ->
      true // nothing to compare
    SuggestedActionConvertToBroadcastGroup.CONSTRUCTOR -> {
      require(this is SuggestedActionConvertToBroadcastGroup && b is SuggestedActionConvertToBroadcastGroup)
      if (COMPILE_CHECK) {
        SuggestedActionConvertToBroadcastGroup(
          this.supergroupId
        )
      }
      this.supergroupId == b.supergroupId
    }
    SuggestedActionExtendPremium.CONSTRUCTOR -> {
      require(this is SuggestedActionExtendPremium && b is SuggestedActionExtendPremium)
      if (COMPILE_CHECK) {
        SuggestedActionExtendPremium(
          this.managePremiumSubscriptionUrl
        )
      }
      this.managePremiumSubscriptionUrl.equalsOrEmpty(b.managePremiumSubscriptionUrl)
    }
    SuggestedActionSetPassword.CONSTRUCTOR -> {
      require(this is SuggestedActionSetPassword && b is SuggestedActionSetPassword)
      if (COMPILE_CHECK) {
        SuggestedActionSetPassword(
          this.authorizationDelay
        )
      }
      this.authorizationDelay == b.authorizationDelay
    }
    else -> {
      assertSuggestedAction_5f4bf3f7()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun TargetChat?.equalsTo(other: TargetChat?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    TargetChatCurrent.CONSTRUCTOR ->
      true // nothing to compare
    TargetChatChosen.CONSTRUCTOR -> {
      require(this is TargetChatChosen && b is TargetChatChosen)
      if (COMPILE_CHECK) {
        TargetChatChosen(
          this.types
        )
      }
      this.types.equalsTo(b.types)
    }
    TargetChatInternalLink.CONSTRUCTOR -> {
      require(this is TargetChatInternalLink && b is TargetChatInternalLink)
      if (COMPILE_CHECK) {
        TargetChatInternalLink(
          this.link
        )
      }
      this.link.equalsTo(b.link)
    }
    else -> {
      assertTargetChat_75ff347c()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun TextEntityType?.equalsTo(other: TextEntityType?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    TextEntityTypeBankCardNumber.CONSTRUCTOR,
    TextEntityTypeBlockQuote.CONSTRUCTOR,
    TextEntityTypeBold.CONSTRUCTOR,
    TextEntityTypeBotCommand.CONSTRUCTOR,
    TextEntityTypeCashtag.CONSTRUCTOR,
    TextEntityTypeCode.CONSTRUCTOR,
    TextEntityTypeEmailAddress.CONSTRUCTOR,
    TextEntityTypeExpandableBlockQuote.CONSTRUCTOR,
    TextEntityTypeHashtag.CONSTRUCTOR,
    TextEntityTypeItalic.CONSTRUCTOR,
    TextEntityTypeMention.CONSTRUCTOR,
    TextEntityTypePhoneNumber.CONSTRUCTOR,
    TextEntityTypePre.CONSTRUCTOR,
    TextEntityTypeSpoiler.CONSTRUCTOR,
    TextEntityTypeStrikethrough.CONSTRUCTOR,
    TextEntityTypeUnderline.CONSTRUCTOR,
    TextEntityTypeUrl.CONSTRUCTOR ->
      true // nothing to compare
    TextEntityTypeCustomEmoji.CONSTRUCTOR -> {
      require(this is TextEntityTypeCustomEmoji && b is TextEntityTypeCustomEmoji)
      if (COMPILE_CHECK) {
        TextEntityTypeCustomEmoji(
          this.customEmojiId
        )
      }
      this.customEmojiId == b.customEmojiId
    }
    TextEntityTypeMediaTimestamp.CONSTRUCTOR -> {
      require(this is TextEntityTypeMediaTimestamp && b is TextEntityTypeMediaTimestamp)
      if (COMPILE_CHECK) {
        TextEntityTypeMediaTimestamp(
          this.mediaTimestamp
        )
      }
      this.mediaTimestamp == b.mediaTimestamp
    }
    TextEntityTypeMentionName.CONSTRUCTOR -> {
      require(this is TextEntityTypeMentionName && b is TextEntityTypeMentionName)
      if (COMPILE_CHECK) {
        TextEntityTypeMentionName(
          this.userId
        )
      }
      this.userId == b.userId
    }
    TextEntityTypePreCode.CONSTRUCTOR -> {
      require(this is TextEntityTypePreCode && b is TextEntityTypePreCode)
      if (COMPILE_CHECK) {
        TextEntityTypePreCode(
          this.language
        )
      }
      this.language.equalsOrEmpty(b.language)
    }
    TextEntityTypeTextUrl.CONSTRUCTOR -> {
      require(this is TextEntityTypeTextUrl && b is TextEntityTypeTextUrl)
      if (COMPILE_CHECK) {
        TextEntityTypeTextUrl(
          this.url
        )
      }
      this.url.equalsOrEmpty(b.url)
    }
    else -> {
      assertTextEntityType_56c1e709()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun ThumbnailFormat?.equalsTo(other: ThumbnailFormat?): Boolean = this.safeEqualsTo(other) { _ ->
  when (this.constructor) {
    ThumbnailFormatGif.CONSTRUCTOR,
    ThumbnailFormatJpeg.CONSTRUCTOR,
    ThumbnailFormatMpeg4.CONSTRUCTOR,
    ThumbnailFormatPng.CONSTRUCTOR,
    ThumbnailFormatTgs.CONSTRUCTOR,
    ThumbnailFormatWebm.CONSTRUCTOR,
    ThumbnailFormatWebp.CONSTRUCTOR ->
      true // nothing to compare
    else -> {
      assertThumbnailFormat_bf2b0de0()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun UserPrivacySettingRule?.equalsTo(other: UserPrivacySettingRule?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    UserPrivacySettingRuleAllowAll.CONSTRUCTOR,
    UserPrivacySettingRuleAllowBots.CONSTRUCTOR,
    UserPrivacySettingRuleAllowContacts.CONSTRUCTOR,
    UserPrivacySettingRuleAllowPremiumUsers.CONSTRUCTOR,
    UserPrivacySettingRuleRestrictAll.CONSTRUCTOR,
    UserPrivacySettingRuleRestrictBots.CONSTRUCTOR,
    UserPrivacySettingRuleRestrictContacts.CONSTRUCTOR ->
      true // nothing to compare
    UserPrivacySettingRuleAllowChatMembers.CONSTRUCTOR -> {
      require(this is UserPrivacySettingRuleAllowChatMembers && b is UserPrivacySettingRuleAllowChatMembers)
      if (COMPILE_CHECK) {
        UserPrivacySettingRuleAllowChatMembers(
          this.chatIds
        )
      }
      this.chatIds.contentEqualsOrEmpty(b.chatIds)
    }
    UserPrivacySettingRuleAllowUsers.CONSTRUCTOR -> {
      require(this is UserPrivacySettingRuleAllowUsers && b is UserPrivacySettingRuleAllowUsers)
      if (COMPILE_CHECK) {
        UserPrivacySettingRuleAllowUsers(
          this.userIds
        )
      }
      this.userIds.contentEqualsOrEmpty(b.userIds)
    }
    UserPrivacySettingRuleRestrictChatMembers.CONSTRUCTOR -> {
      require(this is UserPrivacySettingRuleRestrictChatMembers && b is UserPrivacySettingRuleRestrictChatMembers)
      if (COMPILE_CHECK) {
        UserPrivacySettingRuleRestrictChatMembers(
          this.chatIds
        )
      }
      this.chatIds.contentEqualsOrEmpty(b.chatIds)
    }
    UserPrivacySettingRuleRestrictUsers.CONSTRUCTOR -> {
      require(this is UserPrivacySettingRuleRestrictUsers && b is UserPrivacySettingRuleRestrictUsers)
      if (COMPILE_CHECK) {
        UserPrivacySettingRuleRestrictUsers(
          this.userIds
        )
      }
      this.userIds.contentEqualsOrEmpty(b.userIds)
    }
    else -> {
      assertUserPrivacySettingRule_58b21786()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun UserStatus?.equalsTo(other: UserStatus?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    UserStatusEmpty.CONSTRUCTOR ->
      true // nothing to compare
    UserStatusLastMonth.CONSTRUCTOR -> {
      require(this is UserStatusLastMonth && b is UserStatusLastMonth)
      if (COMPILE_CHECK) {
        UserStatusLastMonth(
          this.byMyPrivacySettings
        )
      }
      this.byMyPrivacySettings == b.byMyPrivacySettings
    }
    UserStatusLastWeek.CONSTRUCTOR -> {
      require(this is UserStatusLastWeek && b is UserStatusLastWeek)
      if (COMPILE_CHECK) {
        UserStatusLastWeek(
          this.byMyPrivacySettings
        )
      }
      this.byMyPrivacySettings == b.byMyPrivacySettings
    }
    UserStatusOffline.CONSTRUCTOR -> {
      require(this is UserStatusOffline && b is UserStatusOffline)
      if (COMPILE_CHECK) {
        UserStatusOffline(
          this.wasOnline
        )
      }
      this.wasOnline == b.wasOnline
    }
    UserStatusOnline.CONSTRUCTOR -> {
      require(this is UserStatusOnline && b is UserStatusOnline)
      if (COMPILE_CHECK) {
        UserStatusOnline(
          this.expires
        )
      }
      this.expires == b.expires
    }
    UserStatusRecently.CONSTRUCTOR -> {
      require(this is UserStatusRecently && b is UserStatusRecently)
      if (COMPILE_CHECK) {
        UserStatusRecently(
          this.byMyPrivacySettings
        )
      }
      this.byMyPrivacySettings == b.byMyPrivacySettings
    }
    else -> {
      assertUserStatus_6492acaf()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun VectorPathCommand?.equalsTo(other: VectorPathCommand?): Boolean = this.safeEqualsTo(other) { b ->
  when (this.constructor) {
    VectorPathCommandCubicBezierCurve.CONSTRUCTOR -> {
      require(this is VectorPathCommandCubicBezierCurve && b is VectorPathCommandCubicBezierCurve)
      if (COMPILE_CHECK) {
        VectorPathCommandCubicBezierCurve(
          this.startControlPoint,
          this.endControlPoint,
          this.endPoint
        )
      }
      this.startControlPoint.equalsTo(b.startControlPoint) &&
      this.endControlPoint.equalsTo(b.endControlPoint) &&
      this.endPoint.equalsTo(b.endPoint)
    }
    VectorPathCommandLine.CONSTRUCTOR -> {
      require(this is VectorPathCommandLine && b is VectorPathCommandLine)
      if (COMPILE_CHECK) {
        VectorPathCommandLine(
          this.endPoint
        )
      }
      this.endPoint.equalsTo(b.endPoint)
    }
    else -> {
      assertVectorPathCommand_4e60caf3()
      throw unsupported(this)
    }
  }
}

@Autogenerated
fun WebAppOpenMode?.equalsTo(other: WebAppOpenMode?): Boolean = this.safeEqualsTo(other) { _ ->
  when (this.constructor) {
    WebAppOpenModeCompact.CONSTRUCTOR,
    WebAppOpenModeFullScreen.CONSTRUCTOR,
    WebAppOpenModeFullSize.CONSTRUCTOR ->
      true // nothing to compare
    else -> {
      assertWebAppOpenMode_b354c84f()
      throw unsupported(this)
    }
  }
}
